# Generated by Django 5.0.6 on 2024-07-16 05:34

from django.db import migrations
from decimal import Decimal

# Define the data based on the provided table and previous logic
SEASONAL_STAGES_DATA = [
    {
        "name": "Flowering",
        "months": "6,7,8",
        "prevalence_p": Decimal("0.050"),
        "pests": ["Mango Leaf Hopper", "Mango Tip Borer"],
        "diseases": ["Powdery Mildew", "Mango Malformation"],
        "parts": ["Flowers", "Leaves", "Branches"]
    },
    {
        "name": "Early Fruit Development (Dry Season)",
        "months": "9,10",
        "prevalence_p": Decimal("0.070"),
        "pests": ["Mango Fruit Fly", "Mango Seed Weevil", "Mango Scale Insect"],
        "diseases": ["Anthracnose", "Bacterial Black Spot", "Stem End Rot"],
        "parts": ["Fruits", "Leaves", "Branches"]
    },
    {
        "name": "Late Fruit Development (Wet Season)",
        "months": "11,12",
        "prevalence_p": Decimal("0.100"),
        "pests": ["Mango Fruit Fly", "Mango Seed Weevil", "Mango Scale Insect"],
        "diseases": ["Anthracnose", "Bacterial Black Spot", "Stem End Rot"],
        "parts": ["Fruits", "Leaves", "Branches", "Stems"]
    },
    {
        "name": "Wet Season (non-fruiting)",
        "months": "1,2,3,4",
        "prevalence_p": Decimal("0.100"),
        "pests": ["Mango Fruit Fly", "Mango Tip Borer", "Mango Scale Insect"],
        "diseases": ["Anthracnose", "Bacterial Black Spot"],
        "parts": ["Leaves", "Branches", "Stems", "Trunk"]
    },
    {
        "name": "Dry Season (non-flowering)",
        "months": "5",
        "prevalence_p": Decimal("0.020"),
        "pests": ["Mango Leaf Hopper", "Mango Tip Borer", "Mango Scale Insect"],
        "diseases": ["Powdery Mildew", "Mango Malformation"],
        "parts": ["Leaves", "Branches", "Stems"]
    }
]

def populate_stages(apps, schema_editor):
    """
    Creates SeasonalStage instances based on the defined data.
    Assumes that the related Pest, Disease, and PlantPart objects
    already exist in the database with the correct names.
    """
    SeasonalStage = apps.get_model('core', 'SeasonalStage')
    Pest = apps.get_model('core', 'Pest')
    Disease = apps.get_model('core', 'Disease')
    PlantPart = apps.get_model('core', 'PlantPart')
    
    # Clear existing stages first to avoid duplicates if run multiple times (optional)
    # SeasonalStage.objects.all().delete() 
    
    print("\nPopulating Seasonal Stages...") # Add print statement
    
    for stage_data in SEASONAL_STAGES_DATA:
        print(f"  Creating/Updating stage: {stage_data['name']}...") # Add print statement
        try:
            # Get or create the stage object
            stage, created = SeasonalStage.objects.update_or_create(
                name=stage_data['name'],
                defaults={
                    'months': stage_data['months'],
                    'prevalence_p': stage_data['prevalence_p']
                }
            )
            
            # --- Link Pests ---
            pest_objects = []
            for pest_name in stage_data['pests']:
                try:
                    pest = Pest.objects.get(name=pest_name)
                    pest_objects.append(pest)
                except Pest.DoesNotExist:
                    print(f"    WARNING: Pest '{pest_name}' not found in database. Skipping for stage '{stage.name}'.")
            stage.active_pests.set(pest_objects) # Use set() for M2M

            # --- Link Diseases ---
            disease_objects = []
            for disease_name in stage_data['diseases']:
                try:
                    disease = Disease.objects.get(name=disease_name)
                    disease_objects.append(disease)
                except Disease.DoesNotExist:
                    print(f"    WARNING: Disease '{disease_name}' not found in database. Skipping for stage '{stage.name}'.")
            stage.active_diseases.set(disease_objects)

            # --- Link Plant Parts ---
            part_objects = []
            for part_name in stage_data['parts']:
                try:
                    part = PlantPart.objects.get(name=part_name)
                    part_objects.append(part)
                except PlantPart.DoesNotExist:
                    print(f"    WARNING: PlantPart '{part_name}' not found in database. Skipping for stage '{stage.name}'.")
            stage.recommended_parts.set(part_objects)
            
            if created:
                print(f"    Successfully created stage: {stage.name}")
            else:
                print(f"    Successfully updated stage: {stage.name}")

        except Exception as e:
            print(f"    ERROR creating/updating stage '{stage_data['name']}': {e}")
            # Decide if you want to stop the migration or continue
            # raise e # Uncomment to stop migration on error
            
    print("Seasonal Stages population complete.") # Add print statement

def reverse_populate_stages(apps, schema_editor):
    """Removes the created stages if the migration is reversed."""
    SeasonalStage = apps.get_model('core', 'SeasonalStage')
    stage_names = [data['name'] for data in SEASONAL_STAGES_DATA]
    print(f"\nReversing population of seasonal stages: {', '.join(stage_names)}...") # Add print statement
    SeasonalStage.objects.filter(name__in=stage_names).delete()
    print("Reversal complete.") # Add print statement


class Migration(migrations.Migration):

    dependencies = [
        ('core', '0012_seasonalstage'), # Depends on the previous migration that created the model
    ]

    operations = [
        migrations.RunPython(populate_stages, reverse_code=reverse_populate_stages),
    ]
